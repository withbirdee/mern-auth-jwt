import { ErrorRequestHandler, Response } from "express";
import { ZodError } from "zod";
import AppError from "../utils/AppError.js";
import { HTTP_STATUS } from "../constants/http.js";
import { clearAuthCookies, REFRESH_PATH } from "../utils/cookies.js";
import { NODE_ENV } from "../constants/env.js";

/**
 * Global Error Handling Middleware
 * Catch-all for operational and unexpected errors across the application.
 */
const errorHandler: ErrorRequestHandler = (err, req, res, next) => {
  /**
   * SECURITY: If an error occurs on the refresh path, the current session
   * is likely compromised or invalid. We proactively clear cookies to
   * prevent the client from getting stuck in an infinite retry loop.
   */
  if (req.path === REFRESH_PATH) {
    clearAuthCookies(res);
  }

  // Handle Malformed JSON (e.g., a trailing comma in a POST body)
  if (
    err instanceof SyntaxError &&
    (err as any).status === 400 &&
    "body" in err
  ) {
    return handleParseError(res);
  }

  // Handle Zod Validation Errors (Schema mismatches)
  if (err instanceof ZodError) {
    return zodErrorHandler(err, res);
  }

  // Handle Custom Operational Errors (AppError instances)
  if (err instanceof AppError) {
    return appErrorHandler(err, res);
  }

  /**
   * FALLBACK: Handle unexpected programmer errors (RefError, TypeErr, etc.)
   * In development, we log the full stack for debugging.
   * In production, we log only the message to prevent sensitive data leaks.
   */
  console.error(`[INTERNAL_ERROR] ${req.method} ${req.path}:`, err);

  return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({
    message: "Internal Server Error",
    ...(NODE_ENV === "development" && { stack: err.stack }),
  });
};

export default errorHandler;

function handleParseError(res: Response) {
  return res.status(HTTP_STATUS.BAD_REQUEST).json({
    message: "Payload is not valid JSON",
  });
}

function zodErrorHandler(err: ZodError, res: Response) {
  const errors = err.issues.map((issue) => ({
    // Conditionally include path only if it exists (handles raw string validation)
    ...(issue.path.length > 0 && { path: issue.path.join(".") }),
    message: issue.message,
  }));

  return res.status(HTTP_STATUS.UNPROCESSABLE_ENTITY).json({ errors });
}

/**
 * Processes custom application errors generated by appAssert or manual throws.
 */
function appErrorHandler(err: AppError, res: Response) {
  return res.status(err.httpStatusCode).json({
    message: err.message,
    // Add extra debugging info if available in development
    ...(err.appErrorCode && { errorCode: err.appErrorCode }),
  });
}
